
// Forge Gradle プラグインのロードを行い
// 必要であれば Kotlin プラグインもロードする
buildscript {
  repositories {
    if ( !forge.gradle.useSnapshot )
      maven { url 'https://plugins.gradle.org/m2/' }
    else
    {
      jcenter()
      maven {
        name 'forge'
        url  'http://files.minecraftforge.net/maven'
      }
    }

    if_kotlinProject { mavenCentral() }
  }
  dependencies {
    if ( !forge.gradle.useSnapshot )
      classpath 'gradle.plugin.net.minecraftforge.gradle:ForgeGradle:2.0.2'
    else
      classpath 'net.minecraftforge.gradle:ForgeGradle:2.1-SNAPSHOT'

    if_kotlinProject
    {
      classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlinVersion"
    }
  }
}
apply plugin: 'net.minecraftforge.gradle.forge'
// 開発言語に Kotlin が指定されていれば
// プラグインのロード, 使用するライブラリの登録などを行う
if_kotlinProject {
  apply plugin: 'kotlin'

  bild.with {
    // ライブラリ取得のためセントラルリポジトリを参照
    maven.repositories.central = true

    if ( dependencies.compile )
      dependencies.compile += kotlinLibraries
    else
      dependencies.compile  = kotlinLibraries
  }
}


// 基本情報の設定
group            = bild.jar.groupId
archivesBaseName = bild.jar.baseName
version          = info.version

// Forge 環境の設定
minecraft {
  version          = forge.version
  runDir           = 'run'
  mappings         = forge.mappings
  makeObfSourceJar = false
}

// コンパイルタスクの設定
tasks.withType( AbstractCompile ) {
  sourceCompatibility = bild.languageLevel
  targetCompatibility = bild.languageLevel

  if ( hasProperty( 'options' ) ) { options.encoding = bild.encoding }
}

// リポジトリの設定
repositories {
  def repoOpt = bild.maven.repositories

  if ( repoOpt.central ) { mavenCentral() }
  if ( repoOpt.local )   { mavenLocal()   }
  if ( repoOpt.jcenter ) { jcenter()      }

  repoOpt.url?.each { x -> maven { url "$x" } }
}

// 依存関係の設定
bild.dependencies.each { k, v ->
  dependencies."$k" v
}

// jar のアトリビュートを設定
jar.manifest.attributes = bild.jar.manifest.attributes


// タスク定義･事前準備 ********************************


// Furge-Gradle ソースコピー･タスクをインポート
import net.minecraftforge.gradle.user.TaskSourceCopy

// メインのソースセットを拡張プロパティにバインド
project.ext.mainSourceSet = sourceSets.main

// オブジェクトのすべての要素を文字列型に変換する関数群
def e2s( Map    obj ) { obj.collectEntries { k, v -> [ "$k": e2s( v ) ] } }
def e2s( List   obj ) { obj.collect { e2s( it ) }                         }
def e2s( Object obj ) { String.valueOf( obj )                             }

// mcmod.info に記述される内容を返すクロージャ
def genMcmodInfoText = {
  def jb = new groovy.json.JsonBuilder( e2s( info ) )
  "[$eol${ jb.toPrettyString() }$eol]"
}


// タスク定義 ********************************


// メインのソースディレクトリを作成するタスク
task makeMainSourceDirs {
  // 作成対象となるディレクトリ一覧を定義
  ext.sourceDirs = mainSourceSet.allSource.srcDirs

  // setupDecompWorkspace が失敗していなければ処理を実行
  onlyIf { setupDecompWorkspace.state.failure == null }

  // 作成対象となるディレクトリがすでに存在していれば処理をスキップ
  outputs.files project.files( sourceDirs )

  doLast { sourceDirs.each project.&mkdir }
}

// Mod の基本パッケージを作成するタスク
task makePackage( dependsOn: makeMainSourceDirs ) {
  ext {
    // 出力先ディレクトリ ( ソースディレクトリ ) 一覧を定義
    destinationDirs = mainSourceSet."${ bild.language }".srcDirs

    // 作成対象となるパッケージ一覧を返すクロージャ
    packages = {
      def pkg = bild.package?.trim() ?: bild.jar.groupId
      destinationDirs.collect { project.file( "$it/${ pkg.replace( '.', '/' ) }" ) }
    }
  }

  // makeMainSourceDirs が失敗していなければ処理を実行
  onlyIf { makeMainSourceDirs.state.failure == null }

  // 作成対象となるパッケージがすでに存在していれば処理をスキップ
  outputs.files project.files( packages() )

  doLast { packages().each project.&mkdir }
}

// アセットディレクトリを作成するタスク
task makeAssetsDir( dependsOn: makeMainSourceDirs ) {
  ext {
    // 出力先ディレクトリ ( ソースディレクトリ ) 一覧を定義
    destinationDirs = mainSourceSet.resources.srcDirs

    // 作成対象となるディレクトリ一覧を返すクロージャ
    assetsDirs = {
      destinationDirs.collect { project.file( "$it/assets/${ info.modid }" ) }
    }
  }

  // makeMainSourceDirs が失敗していなければ処理を実行
  onlyIf { makeMainSourceDirs.state.failure == null }

  // 作成対象となるディレクトリがすでに存在していれば処理をスキップ
  outputs.files project.files( assetsDirs() )

  doLast { assetsDirs().each project.&mkdir }
}

// mcmod.info ファイルを出力するタスク
task genMcmodInfo {
  // 実行されるタスクに makeMainSourceDirs も指定されている場合
  // このタスクは makeMainSourceDirs よりも後に実行される
  mustRunAfter makeMainSourceDirs

  ext {
    // 出力先ディレクトリ ( ソースディレクトリ ) 一覧を定義
    destinationDirs = mainSourceSet.resources.srcDirs

    // 出力ファイル一覧を返すクロージャ
    outputFiles = {
      destinationDirs.collect { project.file( "$it/mcmod.info" ) }
    }
  }

  // setupDecompWorkspace が失敗していなければ処理を実行
  onlyIf { setupDecompWorkspace.state.failure == null }

  // mcmod.info の内容に変更があれば処理を実行
  inputs.property 'mcmod_info', genMcmodInfoText

  // 作成対象となるファイルが存在しなければ処理を実行
  outputs.files project.files( outputFiles() )

  doLast {
    def infoText = genMcmodInfoText()
    outputFiles()*.text = infoText
  }
}

// 各プログラミング言語のソースコピータスクの存在をチェック
// 定義されていなければ新規に定義する
jvmLanguages.findAll { hasPlugin( it ) } each { lang ->
  if ( mainSourceSet[ lang ] ) {
    def sourceCopyTaskName = "sourceMain${ lang.capitalize() }"
    if ( hasTask( sourceCopyTaskName ) ) return

    task "$sourceCopyTaskName"( type: TaskSourceCopy ) {
      setSource mainSourceSet[ lang ]
      setOutput project.file( "$buildDir/sources/$lang" )
    }

    def sourceCopyTask  = tasks."$sourceCopyTaskName"
    def compileTaskName = mainSourceSet.getCompileTaskName( lang )
    def compileTask     = tasks."$compileTaskName"
    compileTask.dependsOn sourceCopyTask
    compileTask.source = project.fileTree( sourceCopyTask.output )
  }
}

// ソースコードのアーカイブを出力するタスクを定義
if ( bild.jar.archive.source ) {
  task sourcesJar( type: Jar, dependsOn: [ processResources ] ) {
    classifier = 'sources'
    from processResources.destinationDir
  }

  // 各プログラミング言語のソースを読み込むようにする
  jvmLanguages.findAll { hasPlugin( it ) } each { lang ->
    def sourceCopyTaskName = "sourceMain${ lang.capitalize() }"
    if ( !hasTask( sourceCopyTaskName ) ) return

    def sourceCopyTask = tasks."$sourceCopyTaskName"
    sourcesJar.dependsOn sourceCopyTask
    sourcesJar.from sourceCopyTask.output
  }

  // Forge Gradle の sourceJar と同じように依存関係を設定
  assemble.dependsOn sourcesJar
  if ( hasPlugin( 'maven' ) ) {
    uploadArchives.dependsOn sourcesJar
  }

  // sourcesJar タスクを有効にする
  artifacts.archives sourcesJar
}

// ドキュメントのアーカイブを出力するタスクを定義
if ( bild.jar.archive.document ) {
  def language           = bild.language
  def docTaskName        = "${ language }doc"
  def sourceCopyTaskName = "sourceMain${ language.capitalize() }"

  // 開発に使用する言語のドキュメント生成タスクと
  // ソースコピータスクが定義されていれば
  // その言語のドキュメントアーカイブ生成タスクを定義する
  if ( hasTask( docTaskName ) && hasTask( sourceCopyTaskName ) ) {
    def docTask        = tasks."$docTaskName"
    def docJarTaskName = "${ docTaskName }Jar"
    def sourceCopyTask = tasks."$sourceCopyTaskName"

    task "$docJarTaskName"( type: Jar, dependsOn: docTask ) {
      classifier = docTaskName
      from docTask.destinationDir
    }

    docTask.source = project.fileTree( sourceCopyTask.output )
    // docJar タスクを有効にする
    artifacts.archives tasks."$docJarTaskName"
  }
  // 条件を満たしていなければ javadoc の
  // アーカイブドキュメント生成タスクを定義する
  else if ( hasTask( 'javadoc' ) && hasTask( 'sourceMainJava' ) ) {
    task javadocJar( type: Jar, dependsOn: javadoc ) {
      classifier = 'javadoc'
      from javadoc.destinationDir
    }

    // javadoc の生成を行うソースを指定
    javadoc.source = project.fileTree( sourceMainJava.output )
    // javadocJar タスクを有効にする
    artifacts.archives javadocJar
  }
}


// タスクの設定を調整 ********************************


// リソースファイルコピー前に mcmod.info を生成するように設定
processResources.dependsOn genMcmodInfo

// 開発環境構築処理の最後に
// 基本パッケージ/アセットディレクトリ/mcmod.info を生成するように設定
setupDecompWorkspace.finalizedBy makePackage,
                                 makeAssetsDir,
                                 genMcmodInfo

// ソースコードコピー･タスクに変数展開用の辞書をセットする
tasks.withType( TaskSourceCopy )*.replace( replacements() )
